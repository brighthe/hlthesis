# Cut 界面网格生成算法
## 算法概述
使用虚单元方法，多边形网格单元也可以用来离散方程，这大大降低了生成界面网格的难度。
本文介绍一种通过界面切割背景网格生成界面网格的方法。
同时该算法也可以用于生成任意多边形区域的多边形网格。

> 本文仅讨论界面不自交的情况，
> 自交的情况可以通过将自交的界面切割成多个不自交的界面来处理。

## 算法
### （1）界面点预处理
- 输入：界面点集合，背景网格
- 输出：界面点集合
- 算法流程： 
1. 循环处理每个界面点 `p`:
    - 如果 `p` 距离背景网格的某条边 `e` 小于 `tol`, 将 `p` 移动到 `e` 上.
    - 如果 `p` 距离背景网格的某个顶点 `v` 小于 `tol`, 将 `p` 移动到 `v` 上.
2. 返回处理后的界面点集合

**经过预处理的界面点集合，可以保证界面点不会距离背景网格的边和顶点太近，
可以增强后续处理的稳定性。**

### （2）计算 segment 与背景网格的交点
#### 首先定义交点 `p` 的信息:
- 交点坐标 `point`
- 交点类型 `type`：`vertex`, `edge`, `cell`
- 交点的半边 `halfedge`：
    - `type` 为 `vertex` 时，`half_edge` 为 指向 `p` 的半边；
    - `type` 为 `edge` 时，`half_edge` 为 `p` 所在的边的半边；
    - `type` 为 `cell` 时，`half_edge` 为 `p` 所在的单元的半边。

#### 算法流程
- 输入：`segment = [p0, p1]`, 背景网格 `mesh`
- 输出：交点集合 `intersections`
- 算法流程：
1. 定义遍历过的边的集合 `traversed_edges` 和可能和 `segment` 有交点的边集合
   `edges`.
2. 找到 `p0` 和 `p1` 所在的背景网格单元 `cell0` 和 `cell1`, 并将 `cell0` 和 `cell1`
   的边加入 `edges`. 
3. 循环处理 `edges`:
    - 如果边 `e` 在 `traversed_edges` 中，跳过。
    - 如果 `segment` 与 `e` 有交点 `p`, 将 `p` 加入 `intersections`，
      并将 `e` 周围单元的所有边加入 `edges`.
    - 将 `e` 加入 `traversed_edges`.
4. 根据与 `p0` 的距离排序 `intersections`，去除重复的交点，
   返回 `intersections`.

**重复的交点只会出现在顶点上，所以去除重复的交点时，直接判断交点是否相等即可，
这样可以增加了鲁棒性**

### （3）CutMesh 算法
#### 给交点 `p` 添加新的信息:
- 入射半边 `halfedge_in`
- 出射半边 `halfedge_out`

#### 算法流程
- 输入：界面点集合 `interface_points`，背景网格
- 输出：界面网格
- 算法流程：
1. 对界面点集合进行预处理，得到处理后的界面点集合.
2. 循环处理每个 `segment`:
    - 计算 `segment` 与背景网格的交点，得到交点集合 `intersections`.
    - 将在边 `e` 上的交点 `p` 插入 `e` 对其二分.
    - 假设 `intersections` 中有 `n` 个交点，那么这些交点组成了 `n-1`
      个线段，循环处理这些线段:
        - `p0` 和 `p1`  分别是线段的两个端点
        - 当 `p0` 和 `p1` 在同一条边上时，设 `p0` 的出射半边和 `p1` 的入射半边
          为空.
        - 当 `p0` 和 `p1` 不在同一条边上时，判断 `(p0+p1)/2` 所在的单元 `c`，
            - 设 `p0` 的出射半边为 `c` 中指向 `p0` 的半边， 
            - 设 `p1` 的入射半边为 `c` 中指向 `p1` 的半边.
    > (**至此，只有 `intersections` 的第一个点的入射半边和最后一个点的出射半边未知.**)
3. 将每个 `intersections` 中的点相连。
   > (**至此，只剩下相邻的 `intersections` 的点还没有连接**)
4. 找到相连，且在同一个单元 `c` 中的 `interface_points`，按逆时针顺序放入集合
   `interface_points_in_cell[c]`.
5. 循环每个 `interface_points_in_cell[c]`, 设第一个 `interface_points` 指标为 `i`，
    最后一个的指标为 `j`，那么
    - 设 `intersections[j]` 的第一个点 `p0` 的入射半边为 `c` 中指向 `p0` 的半边.
    - 设 `intersections[i-1]` 的最后一个点 `p1` 的入射半边为 `c` 中指向 `p1` 的半边.
    - 通过连接这两个点来分割 `c`。
    - 若 `i` 到 `j` 之间有固定点，那么将新加的半边加密并将加密的点移动到该固定点上.




</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>












